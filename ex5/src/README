itayabu 

=======================
=  File Description: = 
=======================
TreeNode- represent a node in the AVLTree.
	TreeNode hold a simple constructor, fields of value, height and pointers to
	the parent of the Node and to its left and right sons.
TreeIterator- Iterator class (implement the Iterator interface). Iterate over 
	the AVLTree and return all the values of the tree in an ascending order.
	Class contain "next" and "hasNext" ad expected from every Iterator, but
	doesn't implement the "remove" method because we were told not to.
	class also contain one private method of minimum, once called from the
	constructor it find the Node contain the minimal value of the tree.
	Iterator is called as a method in the AVLTree.
 

============
=  Design: = 
============
TreeNode- at start it was a nested class, but thinking that any other tree can 
	either use it or extend it its own purpuses, I found it better to have it
	as a "free" class in the package.
Iterator- is a nested class because it has full interaction with the tree, and
	can be changed if the tree is changed. this way I had no need to duplicate
	Nodes or the tree itself.

 General workflow of add(int val)- search for the best possible place val can
 	be, if not exist in tree then we are at the best suiter to be parent,
 	build a node in this place and start checking for height differences
 	upwards. rotate the tree if needed.

 General workflow of delete (int val)- search for val Node in tree, if exist:
 	if Node is a leaf- delete it and update heights upward.
 	if Node is parent for one son- delete it and put Node's son insdeat of this
 		nod, update new heights down the new Node's children, and then update 
 		upward to check height differences.
 	if Node is parent for two- find Node's successor (minimal higher value) and
 	place the successor instead of Node, check successor's old place for height
 	changes downward and height differences upward.
 
 help methods for add:
 	buildNode- construct a new TreeNode as a son of a given Node.
 	
 help methods for delete:
 	deleteLeaf, deleteParentForOne and deleteParentForTwo- three delete methods
 	help to delete the Node in each of this cases as explained in the workflow.
 	
 help methods (for both of add and delete):
  findNodePlace(int val)- search for a node contain this val, or the "closest" 
  Node. add() use it to see if Node exist or not, and place the new Node as a 
  son of the retrieved Node. delete() use it to see if Node exist or not.
  
  getHeightFromLeaf- recursive check for height from the leaf at each Node. 
  increaseHeight- increase the height from root to all children of a Node.
  decreaseHeight- decrease the height from root to all children of a Node.
  
 Rotation methods- this is where it gets interesting: because there are so many
 	cases there are a few methods to handle rotations:
 	
 	simpleRight\LeftRotation: the basic rotation- take the son, make it the 
 	parent, have the old parent as a son, receive calls from complexRotation
 	
 	ComplexRotationLeft\right:  wrap the simple rotation, handle all other
 		Nodes affected from the rotation, receive calls from manageRotations
 	manageRotations- main junction for all rotations: check what rotations are
 		needed and call them, receive direction of the main rotation from the
 		chekHightDiff method.
 	chekHightDiff- check if there is need to rotate and in what direction and 
 		sent the information if needed to the manageRotations. recieve calls
 		from all delete and add methods. 

=============================
=  Questions and answers: =
=============================
Q: Find a series of 12 numbers, such that when they are inserted into an empty AVL tree
one by one, the result is a tree of height 4.
A: what we are looking for is the minimal number of Nodes foe height 4, as we 
	did in the static method findMinNodes. the series of minNodes are 
	1,2,4,7,20,33,54... witch is a kind of fibonacci, and it make scence 
	because to get the next height we need first to pre-balance the tree by 
	adding the minimal nodes to all sub-trees so the tree will not self rotate 
	itself.
	the answer is : 5,3,8,4,7,2,10,1,6,9,11,12

=======================
=  source files: = 
=======================
this file		README
java file		AVLTree
java file		Node
